import os
from utils.llm_utils import run_llm_fallback
import json
from typing import Dict, Any

CUSTOM_PATH = "agents/custom"


os.makedirs(CUSTOM_PATH, exist_ok=True)

AGENT_CODE_PROMPT = """You are generating a ChipLoop workflow agent in Python.

Agent Name: {agent_name}

Structured Digital Design Context (parsed from specification):
{structured_spec_json}

Capability Signature:
{capability_signature}

Import Requirements (include these at the TOP of the generated code):
from agents.base_agent import BaseAgent
from utils.llm_utils import run_llm_fallback
import os
import json

Your generated code must define:

class {sanitized_agent_name}(BaseAgent):

    async def run(self, state):
        structured = state.get("structured_spec_final", {})
        artifact_dir = state["artifact_dir"]

        # Generate or transform design artifacts using `structured`.
        # If code needs to be synthesized (UPF/RTL/CDC/Assertions/etc):
        #   code = await run_llm_fallback("<prompt>")
        #   <save code to artifact_dir>

        return {
            "artifact": None,
            "log": "Generated by {sanitized_agent_name} using structured spec.",
            "code": None
        }

Do NOT print.
Do NOT include markdown fences.
Return only runnable Python code.
"""


from agent_capabilities import AGENT_CAPABILITIES

async def generate_agent(agent_name: str, structured_spec_final: Dict[str, Any]) -> str:
    capability_signature = AGENT_CAPABILITIES.get(agent_name, {})
    sanitized_name = agent_name.replace(" ", "_").replace("-", "_")

    prompt = AGENT_CODE_PROMPT.format(
        agent_name=agent_name,
        sanitized_agent_name=sanitized_name,
        structured_spec_json=json.dumps(structured_spec_final, indent=2),
        capability_signature=json.dumps(capability_signature, indent=2),
    )

    code = await run_llm_fallback(prompt)

    # Remove any accidental ``` wrappers
    final = (
        code.strip()
            .replace("```python", "")
            .replace("```", "")
            .strip()
    )

    # Load base template
    template_path = "backend/agents/templates/base_agent_template.py"
    with open(template_path, "r") as tf:
      template = tf.read()

    # Indent generated logic to fit inside class body
    generated_logic = "\n".join("        " + line for line in final.split("\n"))

    # Merge final agent code into template
    merged = template.format(
      sanitized_agent_name=sanitized_name,
      agent_name=agent_name,
      generated_logic=generated_logic,
    )

    # Write to custom agent directory
    file_path = os.path.join(CUSTOM_PATH, f"{sanitized_name.lower()}.py")
    with open(file_path, "w") as f:
      f.write(merged)

    # ✅ reload so planner + builder see new agent immediately
    reload_custom_agents()

    return file_path

    return file_path
def reload_custom_agents():
    """
    Re-import custom agents so they are available to Workflow Builder / Planner.
    """
    import importlib
    import sys
    from agent_capabilities import AGENT_CAPABILITIES

    custom_dir = CUSTOM_PATH

    for filename in os.listdir(custom_dir):
        if filename.endswith(".py"):
            mod_name = filename[:-3]
            module_path = f"agents.custom.{mod_name}"

            if module_path in sys.modules:
                importlib.reload(sys.modules[module_path])
            else:
                try:
                    imported = importlib.import_module(module_path)
                except Exception as e:
                    print(f"⚠️ Error importing custom agent {mod_name}: {e}")
                    continue

            # Register into capability registry
            AGENT_CAPABILITIES[mod_name] = {"generated": True}


import os
from loguru import logger

def sanitize_class_name(name: str):
    # Convert "Digital Alu Controller Agent" → "DigitalAluControllerAgent"
    return "".join(word.capitalize() for word in name.replace("_", " ").split())

def sanitize_file_name(name: str):
    # Convert to python file name
    return name.lower().replace(" ", "_") + ".py"


def generate_behavioral_agent(agent_name: str, loop_type: str):
    """
    Generate a *functional behavioral agent* that derives both:
       - Finite State Machine behavior
       - Signal role / dataflow mapping

    Folder structure used:
       agents/<loop_type>/<agent_name>.py
    """

    base_dir = os.path.dirname(__file__)  # points to /backend/agents/
    loop_dir = os.path.join(base_dir, loop_type)
    os.makedirs(loop_dir, exist_ok=True)

    file_name = sanitize_file_name(agent_name)
    script_path = os.path.join(loop_dir, file_name)
    class_name = sanitize_class_name(agent_name)

    template_path = os.path.join(base_dir, "base_agent_behavioral_template.txt")
    if not os.path.exists(template_path):
        raise FileNotFoundError(
            f"⚠ Missing behavioral agent template: {template_path}\n"
            f"Create it using Step 1 instructions."
        )

    # Load behavioral template
    with open(template_path, "r", encoding="utf-8") as f:
        template = f.read()

    # Fill placeholders
    generated_code = (
        template
        .replace("{{class_name}}", class_name)
        .replace("{{description}}", f"Behavioral agent for: {agent_name}")
        .replace("{{artifact_name}}", file_name.replace(".py", ""))
    )

    # Write agent source file
    with open(script_path, "w", encoding="utf8") as f:
        f.write(generated_code)

    logger.success(f"✅ Behavioral agent created at: {script_path}")

    return {
        "agent_name": agent_name,
        "class_name": class_name,
        "loop_type": loop_type,
        "path": script_path,
        "description": f"Behavioral agent auto-derived for {agent_name}",
    }
