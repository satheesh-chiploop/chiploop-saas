import os
import re
import json
import shutil
import datetime
import subprocess
from typing import Dict, Any, List, Optional

from utils.artifact_utils import save_text_artifact_and_record


def _now_tag() -> str:
    return datetime.datetime.now().strftime("%Y%m%d_%H%M%S")


def _write_local(path: str, content: str) -> None:
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)


def _detect_top_module(state: Dict[str, Any]) -> str:
    # Prefer explicit
    if state.get("top_module"):
        return state["top_module"]

    # Heuristic from RTL paths
    rtl_files = state.get("rtl_files") or []
    if rtl_files:
        base = os.path.basename(rtl_files[0])
        base = re.sub(r"\.(sv|v)$", "", base, flags=re.IGNORECASE)
        if base:
            return base

    # fallback
    return "dut"


def _rtl_file_list(state: Dict[str, Any]) -> List[str]:
    # ChipLoop often passes artifact_list for hierarchical designs
    artifact_list = state.get("artifact_list") or []
    rtl_files = state.get("rtl_files") or []
    files = []
    for f in artifact_list:
        if isinstance(f, str):
            files.append(f)
    for f in rtl_files:
        if isinstance(f, str):
            files.append(f)

    # de-dupe preserve order
    seen = set()
    out = []
    for f in files:
        if f not in seen:
            seen.add(f)
            out.append(f)
    return out


def _makefile_content(top: str, rtl_rel: List[str]) -> str:
    # Cocotb + Verilator Makefile (runs in tb/)
    # Users run: make SIM=verilator TOPLEVEL=<top> MODULE=test_<top>
    rtl_lines = " \\\n\t".join(rtl_rel) if rtl_rel else "../rtl/*.sv"
    return f"""# Auto-generated by ChipLoop Testbench Generator Agent
# Cocotb + Verilator flow
#
# Usage (from tb/):
#   make
#   make SEED=123
#   make TESTCASE=test_smoke
#   make WAVES=1
#
# Notes:
# - This Makefile expects RTL in ../rtl/ and tests in ./tests/
# - It generates build products under ./sim_build/

TOPLEVEL_LANG ?= verilog
SIM ?= verilator

TOPLEVEL ?= {top}
MODULE ?= test_{top}

# Where cocotb finds python tests
export PYTHONPATH := $(PWD)/tests:$(PYTHONPATH)

# RTL sources
VERILOG_SOURCES = \\
\t{rtl_lines}

# Verilator options
# --trace enables VCD; +define+COCOTB_SIM used for conditional compilation
EXTRA_ARGS += --trace --trace-structs -Wall -Wno-fatal
COMPILE_ARGS += -DCOCOTB_SIM

# Optional waveform
ifeq ($(WAVES),1)
EXTRA_ARGS += --trace
endif

# Seed plumbing (cocotb picks up RANDOM_SEED)
export RANDOM_SEED ?= $(SEED)

# Choose a specific test case (by name) inside cocotb
export TESTCASE ?= $(TESTCASE)

# Use standard cocotb make rules
include $(shell cocotb-config --makefiles)/Makefile.sim
"""


def _cocotb_test_content(top: str) -> str:
    # A practical Cocotb template:
    # - smoke test
    # - constrained-random loop with seed
    # - scoreboard hook points
    # - optional clock/reset helpers
    return f'''"""
Auto-generated by ChipLoop Testbench Generator Agent
Target: Cocotb + Verilator
DUT: {top}

This testbench is intentionally lightweight:
- Directed + constrained-random patterns
- Hooks for scoreboarding and golden model comparison
- Regression-friendly (seed + testcase)
"""

import os
import random
import cocotb
from cocotb.triggers import RisingEdge, Timer
from cocotb.clock import Clock


def _seed() -> int:
    # RANDOM_SEED is set by Makefile (SEED=...).
    s = os.getenv("RANDOM_SEED")
    if s is None:
        return 1
    try:
        return int(s)
    except Exception:
        return 1


async def _maybe_start_clock(dut, clk_name="clk", period_ns=10):
    if hasattr(dut, clk_name):
        clk = getattr(dut, clk_name)
        cocotb.start_soon(Clock(clk, period_ns, units="ns").start())


async def _apply_reset(dut, rst_name="rst_n", cycles=5, active_low=True):
    if not hasattr(dut, rst_name):
        return
    rst = getattr(dut, rst_name)

    # Try to find a clock too
    clk = getattr(dut, "clk", None)

    if active_low:
        rst.value = 0
    else:
        rst.value = 1

    if clk is not None:
        for _ in range(cycles):
            await RisingEdge(clk)
    else:
        await Timer(cycles * 10, units="ns")

    if active_low:
        rst.value = 1
    else:
        rst.value = 0

    if clk is not None:
        await RisingEdge(clk)


class Scoreboard:
    """
    Minimal scoreboard scaffold.
    Extend with:
      - push_expected(...)
      - push_actual(...)
      - compare()
    """
    def __init__(self):
        self.expected = []
        self.actual = []

    def push_expected(self, item):
        self.expected.append(item)

    def push_actual(self, item):
        self.actual.append(item)

    def check(self):
        # Simple length + element check
        assert len(self.expected) == len(self.actual), f"Mismatch lengths: exp={len(self.expected)} act={len(self.actual)}"
        for i, (e, a) in enumerate(zip(self.expected, self.actual)):
            assert e == a, f"Mismatch at {i}: exp={e} act={a}"


@cocotb.test()
async def test_smoke(dut):
    """
    Basic sanity test:
    - Start clock (if clk exists)
    - Apply reset (if rst_n exists)
    - Run a few cycles
    """
    random.seed(_seed())
    await _maybe_start_clock(dut)

    await _apply_reset(dut)

    clk = getattr(dut, "clk", None)
    if clk is not None:
        for _ in range(10):
            await RisingEdge(clk)
    else:
        await Timer(100, units="ns")

    dut._log.info("Smoke test completed.")


@cocotb.test()
async def test_constrained_random(dut):
    """
    Constrained-random loop scaffold.
    Replace signal names and constraints with your DUT interface.
    """
    seed = _seed()
    random.seed(seed)
    dut._log.info(f"CRV seed={seed}")

    await _maybe_start_clock(dut)
    await _apply_reset(dut)

    sb = Scoreboard()

    clk = getattr(dut, "clk", None)
    if clk is None:
        await Timer(10, units="ns")

    # Example knobs
    N = int(os.getenv("NUM_ITERS", "50"))

    for i in range(N):
        # Example random stimulus (edit these names to match DUT)
        # if hasattr(dut, "in_valid"): dut.in_valid.value = 1
        # if hasattr(dut, "in_data"): dut.in_data.value = random.randint(0, 255)

        # Expected model hook (placeholder)
        # exp = golden_model_step(...)
        exp = i  # placeholder
        sb.push_expected(exp)

        # Step sim
        if clk is not None:
            await RisingEdge(clk)
        else:
            await Timer(10, units="ns")

        # Capture actual hook (placeholder)
        # act = int(dut.out_data.value)
        act = i  # placeholder
        sb.push_actual(act)

    # Compare
    sb.check()
    dut._log.info("Constrained-random test completed with scoreboard checks.")
'''


def _read_spec_text(state: Dict[str, Any]) -> str:
    # optional spec summary for embedding into README
    return (state.get("spec_text") or state.get("design_spec") or "").strip()


def run_agent(state: dict) -> dict:
    agent_name = "Testbench Generator Agent"
    print("\nðŸ§ª Running Testbench Generator Agent (Cocotb + Verilator)...")

    workflow_id = state.get("workflow_id", "default")
    workflow_dir = state.get("workflow_dir", f"backend/workflows/{workflow_id}")
    os.makedirs(workflow_dir, exist_ok=True)

    top = _detect_top_module(state)
    rtl_files = _rtl_file_list(state)

    # Create a clean structure:
    #   <workflow_dir>/rtl  (symlinks/copies optional)
    #   <workflow_dir>/tb   (Makefile + tests)
    out_dir = os.path.join(workflow_dir, "verification")
    tb_dir = os.path.join(out_dir, "tb")
    rtl_dir = os.path.join(out_dir, "rtl")
    os.makedirs(tb_dir, exist_ok=True)
    os.makedirs(rtl_dir, exist_ok=True)

    # We don't copy RTL by default; we reference paths. But we provide a manifest.
    manifest = {
        "top_module": top,
        "rtl_files": rtl_files,
        "notes": "RTL files are referenced from original locations unless you copy into verification/rtl.",
    }

    makefile = _makefile_content(top=top, rtl_rel=[os.path.relpath(f, tb_dir) for f in rtl_files] if rtl_files else [])
    test_py = _cocotb_test_content(top=top)

    readme = f"""# ChipLoop Verification Harness (Auto-generated)

## Target Toolchain
- Cocotb (Python testbench)
- Verilator (fast simulation)
- Optional waves: VCD (enable with WAVES=1)

## DUT
- TOPLEVEL: `{top}`

## Files
- `tb/Makefile` : Cocotb+Verilator runner
- `tb/tests/test_{top}.py` : Cocotb tests (smoke + constrained-random scaffold)
- `rtl_manifest.json` : RTL file list used by this harness

## Run
From `backend/workflows/{workflow_id}/verification/tb`:

```bash
make
make SEED=123 WAVES=1
make SEED=999 TESTCASE=test_constrained_random NUM_ITERS=200
